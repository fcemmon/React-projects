'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

require('./includes-polyfill');

var request = require('request');
var debug = require('debug')('prerendercloud');
var LRU = require('lru-cache');
var middlewareCache = null;

// preserve (and send to client) these headers from service.prerender.cloud which originally came from the origin server
var headerWhitelist = ['content-type', 'cache-control', 'strict-transport-security', 'content-security-policy', 'public-key-pins', 'x-frame-options', 'x-xss-protection', 'x-content-type-options'];

var userAgentsToPrerender = ['googlebot', 'yahoo', 'bingbot', 'baiduspider', 'facebookexternalhit', 'twitterbot', 'rogerbot', 'linkedinbot', 'embedly', 'quora link preview', 'showyoubot', 'outbrain', 'pinterest/0.', 'developers.google.com/+/web/snippet', 'slackbot', 'vkShare', 'W3C_Validator', 'redditbot', 'Applebot', 'WhatsApp', 'flipboard', 'tumblr', 'bitlybot'];

var MiddlewareCache = function () {
  function MiddlewareCache(lruCache) {
    _classCallCheck(this, MiddlewareCache);

    this.lruCache = lruCache;

    // this prevCache dump/load is just for tests
    var prevCache = middlewareCache && middlewareCache.lruCache.dump();
    if (prevCache) this.lruCache.load(prevCache);
  }

  _createClass(MiddlewareCache, [{
    key: 'reset',
    value: function reset() {
      this.lruCache.reset();
    }
  }, {
    key: 'clear',
    value: function clear(startsWith) {
      if (!startsWith) throw new Error('must pass what cache key startsWith');

      startsWith = startsWith.replace(/^https?/, '');
      var httpPath = 'http' + startsWith;
      var httpsPath = 'https' + startsWith;

      this.lruCache.forEach(function (v, k, cache) {
        if (k.startsWith(httpPath) || k.startsWith(httpsPath)) cache.del(k);
      });
    }
  }, {
    key: 'set',
    value: function set(url, res) {
      this.lruCache.set(url, res);
    }
  }, {
    key: 'get',
    value: function get(url) {
      return this.lruCache.get(url);
    }
  }]);

  return MiddlewareCache;
}();

var Options = function () {
  function Options() {
    _classCallCheck(this, Options);

    this.reset();
  }

  _createClass(Options, [{
    key: 'reset',
    value: function reset() {
      this.options = {};
    }
  }, {
    key: 'set',
    value: function set(prerenderMiddleware, name, val) {
      if (!Options.validOptions.includes(name)) throw new Error(name + ' is unsupported option');

      this.options[name] = val;

      if (name === 'enableMiddlewareCache' && val === false) {
        middlewareCache = undefined;
      } else if (name.match(/middlewareCache/i)) {
        var lruCache = LRU({
          max: this.options.middlewareCacheMaxBytes || 500000000, // 500MB
          length: function length(n, key) {
            return n.length;
          },
          dispose: function dispose(key, n) {},
          maxAge: this.options.middlewareCacheMaxAge || 0 // 0 is forever
        });
        middlewareCache = new MiddlewareCache(lruCache);
      }

      if (this.options['botsOnly'] && this.options['whitelistUserAgents']) throw new Error("Can't use both botsOnly and whitelistUserAgents");

      return prerenderMiddleware;
    }
  }], [{
    key: 'validOptions',
    get: function get() {
      return ['prerenderServiceUrl', 'prerenderToken', 'beforeRender', 'afterRender', 'whitelistUserAgents', 'botsOnly', 'disableServerCache', 'disableAjaxBypass', 'disableAjaxPreload', 'enableMiddlewareCache', 'middlewareCacheMaxBytes', 'middlewareCacheMaxAge'];
    }
  }]);

  return Options;
}();

var options = new Options();

// http, connect, and express compatible URL parser

var Url = function () {
  function Url(req) {
    _classCallCheck(this, Url);

    this.req = req;
  }

  _createClass(Url, [{
    key: 'protocol',
    get: function get() {
      // http://stackoverflow.com/a/10353248
      // https://github.com/expressjs/express/blob/3c54220a3495a7a2cdf580c3289ee37e835c0190/lib/request.js#L301
      return this.req.connection && this.req.connection.encrypted ? 'https:' : 'http:';
    }
  }, {
    key: 'host',
    get: function get() {
      return this.req.headers.host;
    }
  }, {
    key: 'path',
    get: function get() {
      return this.req.originalUrl;
    }

    // if the path is /admin/new.html, this returns /new.html

  }, {
    key: 'basename',
    get: function get() {
      return '/' + this.req.originalUrl.split('/').pop();
    }
  }]);

  return Url;
}();

var handleSkip = function handleSkip(msg, next) {
  debug(msg);
  console.error('prerendercloud middleware SKIPPED:', msg);
  return next();
};

var Prerender = function () {
  function Prerender(req) {
    _classCallCheck(this, Prerender);

    this.req = req;
    this.url = new Url(req);
  }

  // fulfills promise when service.prerender.cloud response is: 2xx, 4xx
  // rejects promise when request lib errors or service.prerender.cloud response is: 5xx


  _createClass(Prerender, [{
    key: 'get',
    value: function get() {
      var _this = this;

      var url = this._createApiRequestUrl();
      var headers = this._createHeaders();
      var gzip = true;
      debug('prerendering:', url, headers);

      return new Promise(function (res, rej) {
        request({ url: url, headers: headers, gzip: gzip }, function (error, response, body) {
          if (error || response.statusCode === 500) {
            if (error) return rej(error);

            return rej(new Error(body && body.substring(0, 300) || 'server error'));
          } else {
            var _ret = function () {
              var headers = {};
              headerWhitelist.forEach(function (h) {
                if (response.headers[h]) headers[h] = response.headers[h];
              });

              var data = { statusCode: response.statusCode, headers: headers, body: body };

              if (options.options.enableMiddlewareCache && ('' + response.statusCode).startsWith('2') && body && body.length) middlewareCache.set(_this._requestedUrl(), data);

              return {
                v: res(data)
              };
            }();

            if (typeof _ret === "object") return _ret.v;
          }
        });
      });
    }

    // data looks like { statusCode, headers, body }

  }, {
    key: 'writeHttpResponse',
    value: function writeHttpResponse(req, res, next, data) {
      if (options.options.afterRender) process.nextTick(function () {
        return options.options.afterRender(null, req, data);
      });

      try {
        if (data.statusCode === 400) {
          res.statusCode = 400;
          return res.end('service.prerender.cloud can\'t prerender this page due to user error: ' + data.body);
        } else if (data.statusCode === 429) {
          return handleSkip('rate limited due to free tier', next);
        } else {
          res.writeHead(data.statusCode, data.headers);
          return res.end(data.body);
        }
      } catch (error) {
        console.error('unrecoverable prerendercloud middleware error:', error && error.message);
        console.error('submit steps to reproduce here: https://github.com/sanfrancesco/prerendercloud-nodejs/issues');
        throw error;
      }
    }
  }, {
    key: '_shouldPrerender',
    value: function _shouldPrerender() {
      if (!(this.req && this.req.headers)) return false;

      if (this.req.method != 'GET' && this.req.method != 'HEAD') return false;

      return !this._alreadyPrerendered() && this._prerenderableUserAgent() && this._prerenderableExtension();
    }
  }, {
    key: '_createHeaders',
    value: function _createHeaders() {
      var h = {
        'User-Agent': 'prerender-cloud-nodejs-middleware',
        'X-Original-User-Agent': this.req.headers['user-agent']
      };

      var token = options.options.prerenderToken || process.env.PRERENDER_TOKEN;

      if (token) Object.assign(h, { 'X-Prerender-Token': token });

      // disable prerender.cloud caching
      if (options.options.disableServerCache) Object.assign(h, { noCache: true });
      if (options.options.disableAjaxBypass) Object.assign(h, { 'Prerender-Disable-Ajax-Bypass': true });
      if (options.options.disableAjaxPreload) Object.assign(h, { 'Prerender-Disable-Ajax-Preload': true });

      return h;
    }
  }, {
    key: '_createApiRequestUrl',
    value: function _createApiRequestUrl() {
      return this._serviceUrl().replace(/\/+$/, '') + '/' + this._requestedUrl();
    }
  }, {
    key: '_serviceUrl',
    value: function _serviceUrl() {
      return options.options.prerenderServiceUrl || process.env.PRERENDER_SERVICE_URL || 'https://service.prerender.cloud';
    }
  }, {
    key: '_alreadyPrerendered',
    value: function _alreadyPrerendered() {
      return !!this.req.headers['x-prerendered'];
    }
  }, {
    key: '_prerenderableExtension',
    value: function _prerenderableExtension() {
      // doesn't detect index.whatever.html (multiple dots)
      var hasHtmlOrNoExtension = !!this.url.basename.match(/^(([^.]|\.html?)+)$/);

      if (hasHtmlOrNoExtension) return true;

      // hack to handle basenames with multiple dots: index.whatever.html
      var endsInHtml = !!this.url.basename.match(/.html?$/);

      if (endsInHtml) return true;

      return false;
    }
  }, {
    key: '_prerenderableUserAgent',
    value: function _prerenderableUserAgent() {
      var reqUserAgent = this.req.headers['user-agent'];

      if (!reqUserAgent) return false;

      reqUserAgent = reqUserAgent.toLowerCase();

      if (reqUserAgent.match(/prerendercloud/i)) return false;

      if (options.options.whitelistUserAgents) return options.options.whitelistUserAgents.some(function (enabledUserAgent) {
        return reqUserAgent.includes(enabledUserAgent);
      });

      if (!options.options.botsOnly) return true;

      // bots only

      if (this.req.headers['x-bufferbot']) return true;

      if (this.url.path.match(/[?&]_escaped_fragment_/)) return true;

      return userAgentsToPrerender.some(function (enabledUserAgent) {
        return reqUserAgent.includes(enabledUserAgent);
      });
    }
  }, {
    key: '_requestedUrl',
    value: function _requestedUrl() {
      return this.url.protocol + '//' + this.url.host + this.url.path;
    }
  }], [{
    key: 'middleware',
    value: function middleware(req, res, next) {
      var prerender = new Prerender(req);

      if (!prerender._shouldPrerender()) {
        debug('NOT prerendering', req.originalUrl, req.headers);
        return next();
      }

      if (options.options.enableMiddlewareCache) {
        var cached = middlewareCache.get(prerender._requestedUrl());
        if (cached) {
          debug('returning cache', req.originalUrl, req.headers);
          return prerender.writeHttpResponse(req, res, next, cached);
        }
      }

      var remotePrerender = function remotePrerender() {
        return prerender.get().then(function (data) {
          return prerender.writeHttpResponse(req, res, next, data);
        }).catch(function (error) {
          return handleSkip('server error: ' + (error && error.message), next);
        });
      };

      if (options.options.beforeRender) {
        var donePassedToUserBeforeRender = function donePassedToUserBeforeRender(err, stringOrObject) {
          if (!stringOrObject) {
            return remotePrerender();
          } else if (typeof stringOrObject === 'string') {
            return prerender.writeHttpResponse(req, res, next, {
              statusCode: 200,
              headers: {
                "content-type": "text/html; charset=utf-8"
              },
              body: stringOrObject
            });
          } else if (typeof stringOrObject === 'object') {
            return prerender.writeHttpResponse(req, res, next, {
              statusCode: stringOrObject.status,
              headers: {
                "content-type": "text/html; charset=utf-8"
              },
              body: stringOrObject.body
            });
          }
        };
        return options.options.beforeRender(req, donePassedToUserBeforeRender);
      } else {
        return remotePrerender();
      }
    }
  }]);

  return Prerender;
}();

Prerender.middleware.set = options.set.bind(options, Prerender.middleware);
// Prerender.middleware.cache =
Object.defineProperty(Prerender.middleware, 'cache', {
  get: function get() {
    return middlewareCache;
  }
});

// for testing only
Prerender.middleware.resetOptions = options.reset.bind(options);

module.exports = Prerender.middleware;